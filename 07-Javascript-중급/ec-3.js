// var obj = {};
var obj = {}, price = 100 ;
obj.music = function (param1, param2){
	debugger; // 여기 단계에서 execution context 생각
	return param1+param2};
obj.music(1,2);

/*
	함수코드 : {
		호출한 함수가 속한 오브젝트: {},
		함수 코드: {},
		호출한 함수의 파라미터 값: {}
	}

	EC: {
		
		LEC: {
			환경 레코드: {
				선언적 환경 레코드: {}
			},
			외부 렉시컬 환경: {
	
			}
		},
		VEC: {
			환경 레코드: {
				선언적 환경 레코드: {}
			},
			외부 렉시컬 환경: {
	
			}
		},
		TBC: {
			호출한 함수가 속한 오브젝트의 프로퍼티: {}
		},

		_LE: {
			환경 레코드: {
				선언적 환경 레코드: {
					param1: 11,
					param2: 22
				}
			},
			외부 렉시컬 환경: {
	
			}
		}

	}

 */

/*

	1. 실행 컨텍스트(EC)를 생성
	2. 세 개의 파라미터를 갖고 실행 컨텍스트 안으로 들어갑니다.
	- 호출한 함수가 속한 오브젝트, 함수 코드, 호출한 함수의 파라미터 값

	3. 렉시컬 환경 컴포넌트(LEC)를 생성
	4. 변수 환경 컴포넌트(VEC)를 생성
	5. this 바인딩 컴포넌트(TBC)를 생성
	6. 호출한 함수가 속한 오브젝트의 프로퍼티를 this 바인딩 컴포넌트에 설정

	7. 새로운 렉시컬 환경(_LE)을 생성

	8. 환경 레코드(?)를 생성하여 생성한 렉시컬 환경에 첨부
	9. 선언적 환경 레코드(?)를 생성하여 환경 레코드에 첨부
	- 아직 함수 코드를 해석하지 않았으므로 빈 상태

	10. 외부 렉시컬 환경 참조를 생성하여 렉시컬 환경에 첨부
	11. 호출한 함수 오브젝트의 [[Scope]]를 외부 렉시컬 환경 참조에 설정

	12. 렉시컬 환경(LE)을 렉시컬 환경 컴포넌트(LEC)에 설정
	13. 렉시컬 환경(LE)을 변수 환경 컴포넌트(VEC)에 설정
	- 렉시컬 환경 컴포넌트와 변수환경 컴포넌트의 초깃값이 같음

 */


 /*
 
	** 엔진 관점에서 출력된 값의 논리를 제시
	함수의 파라미터 값이 매핑되는 과정을 {key: value}

	** 함수 형태
	function sports(one, two, two)(js.log(one+two);)
	sports(11, 22, 55);
	두 번째, 세 번째 파라미터 이름이 같습니다.
	힌트: 파라미터 식별자 해결 기준

  */